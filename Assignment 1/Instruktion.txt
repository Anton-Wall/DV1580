Introduction
In this assignment, you will develop a custom memory manager that handles dynamic memory allocation, which you will then use to implement a single linked list. This foundational project will help you understand memory management concepts in C.

Description
You are to create a memory manager that can efficiently allocate, deallocate, and resize memory blocks (described in more details in Section 3). Afterwards, you would use this memory manager to implement a linked list that manages its elements using your custom memory functions (described in more details in section 4).

Task 1:Implementation of a custom memory manager
For this task, you are expected to create a basic memory manager in C, which allows for dynamic allocation, deallocation, and resizing of memory blocks.

You are expected to implement the following interface / functions:

Initialization function

void mem_init(size_t size);

Initializes the memory manager with a specified size of memory pool. The memory pool could be any data structure, for instance, a large array or a similar contuguous block of memory. (You do not have to interact directly with the hardware or the operating systemâ€™s memory management functions).

Allocation function

void* mem_alloc(size_t size);

Allocates a block of memory of the specified size. Find a suitable block in the pool, mark it as allocated, and return the pointer to the start of the allocated block.

Deallocation function

void mem_free(void* block);

Frees the specified block of memory. For allocation and deallocation, you need a way to track which parts of the memory pool are free and which are allocated.

Resize function

void* mem_resize(void* block, size_t size)

Changes the size of the memory block, possibly moving it.

Deinit function

void mem_deinit();

Frees up the memory pool that was initially allocated by the mem_init function, ensuring that all allocated memory is returned to the system.

 

You are encouraged to use a simple allocation strategy, such as the first-fit or best-fit.

First Fit - searches for the first free partition that is large enough to accommodate the allocation request. (Faster allocation speed)

Best Fit - searches the entire list of memory blocks and select the smallest block that is big enough to satisfy the request. (Better fragmentation)

You should also implement error handling and boundary checking for robustness.

Task 2: Linked List Implementation
Use the memory manager to implement basic operations of a singly linked list: insertion, deletion, and traversal.

Below you may find a simple and straightforward interface that defines the primary operations for a linked list that utilizes your custom memory manager.

Before we define the functions, we can define a structure named Node that we can use during the implementation:

  typedef struct Node {
    uint16_t data; // Stores the data as an unsigned 16-bit integer
    struct Node* next; // A pointer to the next node in the List
  }
You are expected to implement the following interface / functions:

Initialization function

void list_init(Node** head);

This function sets up the list and prepares it for operations.

Insertion function(s)

void list_insert(Node** head, int data);

Adds a new node with the specified data to the linked list. The new node will be added after the last node, known as inserting at the rear end. Feel free to extend this function to allow insertions at any position.

void list_insert_after(Node* prev_node, int data);

Inserts a new node with the specified data immediately after a given node.

void list_insert_before(Node** head, Node* next_node, int data);

Inserts a new node with the specified data immediately before a given node in the list. A bit trickier than list_insert_after method. You have to consider cases when the next_node is the head, you need to find the previous node (note this is a single linked list), ...

Deletion function

void list_delete(Node** head, int data);

Removes a node with the specified data from the linked list.

Search function

Node* list_search(Node** head, int data);

Searches for a node with the specified data and returns a pointer to it.

Display function(s)

void list_display(Node** head);

Prints all the elements in the linked list. The expected output format is to display each element of the linked list separated by commas, enclosed in square brackets. For example [10, 20, 30, 40, ...]

void list_display(Node** head, Node* start_node, Node* end_node);

Prints all elements of the list between two nodes (start_node and end_node). If start_node is 0, it should start from the beginning. If end_node is -1, it should print until the end. I.e., a range[0,-1] should print all elements of the list.

Nodes count function

int list_count_nodes(Node** head);

Will simply return the count of nodes. You can either keep track of the number of nodes in a variable (which would require incrementing or decrementing everytime a new node is added, respectively deleted), or iterate over all nodes starting from the head and count them until it reaches the end of the list.

Cleanup function

void list_cleanup(Node** head);

Frees all the nodes in the linked list. Important to prevent memory leaks.

Note that all of these function, especially the list_insert and list_cleanup will interact with the custom memory manager, so you should use mem_alloc and mem_free instead of using malloc and free.

Also note that you should implement error handling, to prevent cases like attempting to delete from an empty list or insert into a full memory pool.

Requirements and Submission
Ensure compliance with the following requirements for this assignment:

Programming Language: All code must be written in C.

Operating System: The code must compile and run on Linux systems.

Standards Compliance: Use POSIX standards for all system-level interactions to ensure portability and adherence to industry practices.

Interface Adherence: Strictly follow the provided interfaces to facilitate seamless testing and integration.

Documentation: Provide comprehensive documentation for each function, detailing the main functionality, parameter usage, and how edge cases and potential errors are handled.

Error Handling: Implement robust error handling, particularly for critical operations like memory management. Consider scenarios such as deallocating the same memory block twice and document how these are managed.

 

For the submission process, adhere to the following guidelines:

Submission Format:
Clone the reference repo (hereLinks to an external site.); submit your Github repo (only accessible to CodeGrade + examiner within CodeGrade). Make sure that the file requirements are maintained. 

Code Testing: Be prepared for automatic testing through CodeGrade. Specific instructions and criteria for this testing will be provided closer to the submission deadline to ensure that you can adequately prepare your submissions.

This tool needs to be loaded in a new browser window